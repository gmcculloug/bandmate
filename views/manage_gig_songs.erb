<div style="display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 20px;">
    <div style="display: flex; align-items: center; gap: 10px;">
        <!-- Burger Menu Button -->
        <button type="button" id="burger-menu" onclick="toggleAvailableSongs()" style="background: #667eea; color: white; border: none; border-radius: 6px; padding: 8px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <div class="burger-icon">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </button>
        <h2 style="margin: 0;">Manage Songs: <%= @gig.name %></h2>
        <button type="button" id="undo-button" class="btn btn-secondary" onclick="undoLastCommand()" disabled
                style="display: flex; align-items: center; gap: 6px; padding: 8px 12px;">
            <span style="font-size: 1.1rem;">â†¶</span>
            <span>Undo</span>
        </button>
    </div>

    <div class="actions" style="display: flex; gap: 15px; align-items: center;">
        <div id="save-status" class="save-status" style="font-size: 0.9rem; color: #4a5568; display: none;">
            Saving...
        </div>
    </div>
</div>

<div style="margin-bottom: 20px;">
    <p style="margin: 0; font-size: 0.85rem; color: #6b7280; line-height: 1.4;">
        <span style="color: #4f46e5; font-weight: 500;">ðŸ’¡ Quick Actions:</span>
        <strong>Double-click</strong> a song in Available Songs to add it to the selected set â€¢ <strong>Double-click</strong> a song in any set to move it back to Available Songs
    </p>
</div>



<div id="main-container" class="grid-layout" style="grid-template-columns: 300px 1fr; gap: 20px;">
    <!-- Available Songs Column -->
    <div class="card" id="available-songs-column">
        <div style="margin-bottom: 15px;">
            <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap; margin-bottom: 12px;">
                <div>
                    <label for="num_sets" style="font-weight: bold; margin-right: 8px; font-size: 0.9rem;">Number of Sets:</label>
                    <select id="num_sets" style="padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 0.9rem;">
                        <option value="1">1</option>
                        <option value="2" selected>2</option>
                        <option value="3">3</option>
                    </select>
                </div>

                <div style="padding: 6px 12px; background: #f7fafc; border-radius: 4px; border: 1px solid #e2e8f0;">
                    <span style="font-weight: bold; color: #4a5568; font-size: 0.85rem;">Total Time:</span>
                    <span id="total-time" style="color: #2d3748; margin-left: 6px; font-size: 0.85rem;">0:00</span>
                </div>
            </div>
            <h3 style="margin: 0;">Available Songs (<span id="available-count"><%= @available_songs.count %></span>)</h3>
            <div id="selected-set-indicator" style="margin-top: 8px; padding: 6px 10px; background: #e3f2fd; border: 1px solid #90caf9; border-radius: 4px; font-size: 0.85rem; color: #1565c0;">
                <strong>Adding to:</strong> <span id="selected-set-name">Set 1</span>
            </div>
        </div>
        
        <div id="available-songs-content">
            <div style="margin-bottom: 15px; position: relative;">
                <input type="text" id="song-filter" placeholder="Search songs..." style="width: 100%; padding: 8px 30px 8px 8px; border: 1px solid #d1d5db; border-radius: 4px;">
                <button type="button" id="clear-filter" onclick="clearSongFilter()" style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; color: #9ca3af; cursor: pointer; font-size: 16px; padding: 0; width: 20px; height: 20px; display: none; align-items: center; justify-content: center;">Ã—</button>
            </div>
            
            <div id="available-songs" style="overflow-y: scroll; border: 1px solid #e2e8f0; border-radius: 6px; padding: 10px;">
            <% @available_songs.each do |song| %>
                <div class="song-item available-song" data-song-id="<%= song.id %>" draggable="true" style="margin-bottom: 8px; padding: 10px; background: #f7fafc; border: 1px solid #e2e8f0; border-radius: 6px; cursor: grab; transition: all 0.2s ease;">
                    <div style="font-weight: bold; color: #2d3748; font-size: 0.9rem;">
                        <%= song.title %>
                        <% if song.key.present? %>
                            <span style="background: #667eea; color: white; padding: 2px 6px; border-radius: 10px; font-size: 0.7rem; margin-left: 8px;"><%= song.key %></span>
                        <% end %>
                    </div>
                </div>
            <% end %>
            </div>
        </div>
    </div>
    
    <!-- Sets Columns -->
    <div id="sets-container" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px;">
        <!-- Sets will be dynamically generated here -->
        <div class="loading-message" style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #718096;">
            Loading sets...
        </div>
    </div>
</div>

<script>
// Global variables
let draggedElement = null;
let currentSets = 2;
let allBandSongs = [];
let setsSongs = {};
let availableSongsCollapsed = false;
let selectedSet = 1; // Track which set is selected for adding songs

// Auto-save and undo state management
let stateHistory = [];           // Array of state snapshots (max 50 operations)
let currentHistoryIndex = -1;    // Current position in history
let pendingSaveTimeout = null;   // Debounced auto-save timer (2 seconds)
let saveStatus = 'saved';        // 'saving', 'saved', 'error'
let isOnline = navigator.onLine; // Track connectivity status

// Command Pattern Implementation
class Command {
    constructor(description) {
        this.description = description;
        this.timestamp = new Date();
    }

    execute() {
        throw new Error('Execute method must be implemented');
    }

    undo() {
        throw new Error('Undo method must be implemented');
    }
}

class AddSongCommand extends Command {
    constructor(songData, setNumber, insertPosition = -1) {
        super(`Add "${songData.title}" to Set ${setNumber}`);
        this.songData = songData;
        this.setNumber = setNumber;
        this.insertPosition = insertPosition; // -1 means add to end
        this.actualPosition = insertPosition;
    }

    execute() {
        if (!setsSongs[this.setNumber]) {
            setsSongs[this.setNumber] = [];
        }

        // Add transition data if not present
        const songWithTransitionData = {
            ...this.songData,
            transition_data: this.songData.transition_data || {
                has_transition: false,
                transition_type: '',
                transition_notes: '',
                transition_timing: ''
            }
        };

        if (this.insertPosition === -1) {
            this.actualPosition = setsSongs[this.setNumber].length;
            setsSongs[this.setNumber].push(songWithTransitionData);
        } else {
            this.actualPosition = this.insertPosition;
            setsSongs[this.setNumber].splice(this.insertPosition, 0, songWithTransitionData);
        }

        rebuildSet(this.setNumber);
        updateAvailableSongs();
        updateSetCount(this.setNumber);
        updateTotalTime();
    }

    undo() {
        if (setsSongs[this.setNumber] && this.actualPosition >= 0 && this.actualPosition < setsSongs[this.setNumber].length) {
            setsSongs[this.setNumber].splice(this.actualPosition, 1);
            rebuildSet(this.setNumber);
            updateAvailableSongs();
            updateSetCount(this.setNumber);
            updateTotalTime();
        }
    }
}

class RemoveSongCommand extends Command {
    constructor(songId, setNumber) {
        super(`Remove song from Set ${setNumber}`);
        this.songId = songId;
        this.setNumber = setNumber;
        this.removedSong = null;
        this.removedPosition = -1;
        this.previousSongTransition = null;
        this.nextSongTransition = null;
    }

    execute() {
        if (!setsSongs[this.setNumber]) return;

        const songIndex = setsSongs[this.setNumber].findIndex(song => song.id === this.songId);
        if (songIndex === -1) return;

        this.removedSong = setsSongs[this.setNumber][songIndex];
        this.removedPosition = songIndex;
        this.description = `Remove "${this.removedSong.title}" from Set ${this.setNumber}`;

        // Store transition states for restoration
        if (songIndex > 0) {
            this.previousSongTransition = { ...setsSongs[this.setNumber][songIndex - 1].transition_data };
        }
        if (songIndex < setsSongs[this.setNumber].length - 1) {
            this.nextSongTransition = { ...setsSongs[this.setNumber][songIndex + 1].transition_data };
        }

        // Clean up transitions as in original code
        if (this.removedSong.transition_data?.has_transition) {
            this.removedSong.transition_data.has_transition = false;
            this.removedSong.transition_data.transition_type = '';
            this.removedSong.transition_data.transition_notes = '';
            this.removedSong.transition_data.transition_timing = '';
        }

        if (songIndex > 0) {
            const prevSong = setsSongs[this.setNumber][songIndex - 1];
            if (prevSong.transition_data?.has_transition) {
                prevSong.transition_data.has_transition = false;
                prevSong.transition_data.transition_type = '';
                prevSong.transition_data.transition_notes = '';
                prevSong.transition_data.transition_timing = '';
            }
        }

        setsSongs[this.setNumber].splice(songIndex, 1);
        rebuildSet(this.setNumber);
        updateAvailableSongs();
        updateSetCount(this.setNumber);
        updateTotalTime();
    }

    undo() {
        if (!this.removedSong || this.removedPosition === -1) return;

        if (!setsSongs[this.setNumber]) {
            setsSongs[this.setNumber] = [];
        }

        // Restore song at original position
        setsSongs[this.setNumber].splice(this.removedPosition, 0, this.removedSong);

        // Restore transition states
        if (this.removedPosition > 0 && this.previousSongTransition) {
            setsSongs[this.setNumber][this.removedPosition - 1].transition_data = this.previousSongTransition;
        }
        if (this.removedPosition < setsSongs[this.setNumber].length - 1 && this.nextSongTransition) {
            setsSongs[this.setNumber][this.removedPosition + 1].transition_data = this.nextSongTransition;
        }

        rebuildSet(this.setNumber);
        updateAvailableSongs();
        updateSetCount(this.setNumber);
        updateTotalTime();
    }
}

class ToggleTransitionCommand extends Command {
    constructor(songId, setNumber, oldTransitionData) {
        super(`Toggle transition for song in Set ${setNumber}`);
        this.songId = songId;
        this.setNumber = setNumber;
        this.oldTransitionData = oldTransitionData ? { ...oldTransitionData } : null;
        this.newTransitionData = null;
    }

    execute() {
        if (!setsSongs[this.setNumber]) return;

        const songIndex = setsSongs[this.setNumber].findIndex(song => song.id === this.songId);
        if (songIndex === -1) return;

        const song = setsSongs[this.setNumber][songIndex];
        this.description = `Toggle transition for "${song.title}" in Set ${this.setNumber}`;

        // Store old state if not already stored
        if (!this.oldTransitionData && song.transition_data) {
            this.oldTransitionData = { ...song.transition_data };
        }

        // Toggle transition state
        const newState = !song.transition_data?.has_transition;
        song.transition_data = {
            has_transition: newState,
            transition_type: newState ? (this.oldTransitionData?.transition_type || '') : '',
            transition_notes: newState ? (this.oldTransitionData?.transition_notes || '') : '',
            transition_timing: newState ? (this.oldTransitionData?.transition_timing || '') : ''
        };

        this.newTransitionData = { ...song.transition_data };
        rebuildSet(this.setNumber);
    }

    undo() {
        if (!setsSongs[this.setNumber] || !this.oldTransitionData) return;

        const songIndex = setsSongs[this.setNumber].findIndex(song => song.id === this.songId);
        if (songIndex === -1) return;

        setsSongs[this.setNumber][songIndex].transition_data = { ...this.oldTransitionData };
        rebuildSet(this.setNumber);
    }
}


class ChangeSetCountCommand extends Command {
    constructor(oldSetCount, newSetCount) {
        super(`Change set count from ${oldSetCount} to ${newSetCount}`);
        this.oldSetCount = oldSetCount;
        this.newSetCount = newSetCount;
        this.removedSongs = {}; // Store songs that were removed from deleted sets
    }

    execute() {
        // If reducing sets, store songs from removed sets
        if (this.newSetCount < this.oldSetCount) {
            for (let i = this.newSetCount + 1; i <= this.oldSetCount; i++) {
                if (setsSongs[i] && setsSongs[i].length > 0) {
                    this.removedSongs[i] = [...setsSongs[i]];
                }
                delete setsSongs[i];
            }
        }

        currentSets = this.newSetCount;

        // Reset selected set if invalid
        if (selectedSet > currentSets) {
            selectedSet = 1;
        }

        document.getElementById('num_sets').value = currentSets;
        generateSets();
        updateAvailableSongs();
        updateAllSetTimes();
        updateTotalTime();
        setupSetSelectionListeners();
    }

    undo() {
        currentSets = this.oldSetCount;

        // Restore removed songs
        Object.keys(this.removedSongs).forEach(setNumber => {
            setsSongs[setNumber] = [...this.removedSongs[setNumber]];
        });

        // Reset selected set if it was changed
        if (selectedSet > currentSets) {
            selectedSet = 1;
        }

        document.getElementById('num_sets').value = currentSets;
        generateSets();
        updateAvailableSongs();
        updateAllSetTimes();
        updateTotalTime();
        setupSetSelectionListeners();
    }
}

class ReorderSongCommand extends Command {
    constructor(songId, fromSet, fromPosition, toSet, toPosition) {
        super(`Move song between sets`);
        this.songId = songId;
        this.fromSet = fromSet;
        this.fromPosition = fromPosition;
        this.toSet = toSet;
        this.toPosition = toPosition;
        this.songData = null;
    }

    execute() {
        // Find and store the song data
        if (setsSongs[this.fromSet] && setsSongs[this.fromSet][this.fromPosition]) {
            this.songData = { ...setsSongs[this.fromSet][this.fromPosition] };
            this.description = `Move "${this.songData.title}" from Set ${this.fromSet} to Set ${this.toSet}`;

            // Remove from old position
            setsSongs[this.fromSet].splice(this.fromPosition, 1);

            // Add to new position
            if (!setsSongs[this.toSet]) {
                setsSongs[this.toSet] = [];
            }
            setsSongs[this.toSet].splice(this.toPosition, 0, this.songData);

            // Update UI
            rebuildSet(this.fromSet);
            if (this.fromSet !== this.toSet) {
                rebuildSet(this.toSet);
            }
            updateAvailableSongs();
            updateSetCount(this.fromSet);
            if (this.fromSet !== this.toSet) {
                updateSetCount(this.toSet);
            }
            updateTotalTime();
        }
    }

    undo() {
        if (!this.songData) return;

        // Remove from current position
        if (setsSongs[this.toSet]) {
            const currentIndex = setsSongs[this.toSet].findIndex(song => song.id === this.songId);
            if (currentIndex !== -1) {
                setsSongs[this.toSet].splice(currentIndex, 1);
            }
        }

        // Restore to original position
        if (!setsSongs[this.fromSet]) {
            setsSongs[this.fromSet] = [];
        }
        setsSongs[this.fromSet].splice(this.fromPosition, 0, this.songData);

        // Update UI
        rebuildSet(this.fromSet);
        if (this.fromSet !== this.toSet) {
            rebuildSet(this.toSet);
        }
        updateAvailableSongs();
        updateSetCount(this.fromSet);
        if (this.fromSet !== this.toSet) {
            updateSetCount(this.toSet);
        }
        updateTotalTime();
    }
}

// Practice State Visual Functions (Read-only indicators for gig planning awareness)
function createPracticeStateHTML(song) {
    const isPractice = song.practice_state || false;
    const badgeDisplay = isPractice ? 'inline' : 'none';

    return {
        badge: `<span class="practice-badge" style="display: ${badgeDisplay}; background: #28a745; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; font-weight: bold;">P</span>`
    };
}

// State History Management System
function executeCommand(command) {
    if (!isOnline) {
        showOfflineMessage();
        return false;
    }

    try {
        // Execute the command
        command.execute();

        // Add to history (remove any redo history if we're in the middle)
        if (currentHistoryIndex < stateHistory.length - 1) {
            stateHistory.splice(currentHistoryIndex + 1);
        }

        stateHistory.push(command);
        currentHistoryIndex++;

        // Limit history size to 50 operations
        if (stateHistory.length > 50) {
            stateHistory.shift();
            currentHistoryIndex--;
        }

        // Update UI state
        updateUndoButtonState();

        // Trigger auto-save
        scheduleAutoSave();

        return true;
    } catch (error) {
        console.error('Error executing command:', error);
        showErrorMessage('An error occurred. Please try again.');
        return false;
    }
}

function undoLastCommand() {
    if (currentHistoryIndex < 0 || stateHistory.length === 0) {
        return false;
    }

    if (!isOnline) {
        showOfflineMessage();
        return false;
    }

    try {
        const command = stateHistory[currentHistoryIndex];
        command.undo();
        currentHistoryIndex--;

        // Update UI state
        updateUndoButtonState();

        // Trigger auto-save
        scheduleAutoSave();

        return true;
    } catch (error) {
        console.error('Error undoing command:', error);
        showErrorMessage('An error occurred while undoing. Please try again.');
        return false;
    }
}

function getLastCommandDescription() {
    if (currentHistoryIndex >= 0 && stateHistory.length > 0) {
        return stateHistory[currentHistoryIndex].description;
    }
    return null;
}

function hasUndoHistory() {
    return currentHistoryIndex >= 0 && stateHistory.length > 0;
}

// Auto-save functionality
function scheduleAutoSave() {
    // Clear any pending save
    if (pendingSaveTimeout) {
        clearTimeout(pendingSaveTimeout);
    }

    // Update save status
    saveStatus = 'pending';
    updateSaveStatusDisplay();

    // Schedule new save with 2-second debounce
    pendingSaveTimeout = setTimeout(performAutoSave, 2000);
}

function performAutoSave() {
    if (!isOnline) {
        saveStatus = 'error';
        updateSaveStatusDisplay();
        return;
    }

    saveStatus = 'saving';
    updateSaveStatusDisplay();

    const formData = new FormData();

    // Add sets data with transition information (same as original saveSongChanges)
    Object.keys(setsSongs).forEach(setNumber => {
        setsSongs[setNumber].forEach((song, index) => {
            formData.append(`sets[${setNumber}][]`, song.id);

            // Include transition data for this song
            if (song.transition_data) {
                formData.append(`transitions[${setNumber}][${song.id}][has_transition]`, song.transition_data.has_transition || false);
                formData.append(`transitions[${setNumber}][${song.id}][transition_type]`, song.transition_data.transition_type || '');
                formData.append(`transitions[${setNumber}][${song.id}][transition_notes]`, song.transition_data.transition_notes || '');
                formData.append(`transitions[${setNumber}][${song.id}][transition_timing]`, song.transition_data.transition_timing || '');
            }
        });
    });

    fetch('/gigs/<%= @gig.id %>/update_songs', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            saveStatus = 'saved';
            lastSaveTime = new Date();
        } else {
            saveStatus = 'error';
            console.error('Auto-save failed:', data.error);
        }
        updateSaveStatusDisplay();
    })
    .catch(error => {
        saveStatus = 'error';
        console.error('Auto-save error:', error);
        updateSaveStatusDisplay();
    });
}

// UI State Management
function updateUndoButtonState() {
    const undoButton = document.getElementById('undo-button');
    if (undoButton) {
        const canUndo = hasUndoHistory();
        undoButton.disabled = !canUndo || !isOnline;

        if (canUndo) {
            const lastCommand = getLastCommandDescription();
            undoButton.title = `Undo: ${lastCommand}`;
            undoButton.setAttribute('aria-label', `Undo: ${lastCommand}`);
        } else {
            undoButton.title = 'Nothing to undo';
            undoButton.setAttribute('aria-label', 'Nothing to undo');
        }
    }
}

let lastSaveTime = new Date();

function updateSaveStatusDisplay() {
    const statusElement = document.getElementById('save-status');
    if (!statusElement) return;

    switch (saveStatus) {
        case 'saving':
            statusElement.textContent = 'Saving...';
            statusElement.className = 'save-status saving';
            statusElement.style.display = 'block';
            statusElement.onclick = null;
            break;
        case 'saved':
            // Hide the status after a brief delay when saved
            setTimeout(() => {
                if (statusElement && saveStatus === 'saved') {
                    statusElement.className = 'save-status';
                    // Use a longer timeout to allow the CSS transition to complete
                    setTimeout(() => {
                        statusElement.style.display = 'none';
                    }, 300); // Wait for CSS transition
                }
            }, 1200); // Show for 1.2 seconds
            break;
        case 'error':
            statusElement.textContent = 'Error - Click to retry';
            statusElement.className = 'save-status error';
            statusElement.style.display = 'block';
            statusElement.onclick = () => {
                saveStatus = 'pending';
                scheduleAutoSave();
            };
            break;
        case 'pending':
            // Don't show pending status, wait for actual saving
            statusElement.className = 'save-status';
            setTimeout(() => {
                statusElement.style.display = 'none';
            }, 300); // Allow transition
            break;
        default:
            statusElement.className = 'save-status';
            setTimeout(() => {
                statusElement.style.display = 'none';
            }, 300); // Allow transition
            break;
    }
}

function getTimeAgoString(date) {
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / (1000 * 60));

    if (diffMins < 1) return 'just now';
    if (diffMins === 1) return '1 minute ago';
    if (diffMins < 60) return `${diffMins} minutes ago`;

    const diffHours = Math.floor(diffMins / 60);
    if (diffHours === 1) return '1 hour ago';
    if (diffHours < 24) return `${diffHours} hours ago`;

    const diffDays = Math.floor(diffHours / 24);
    if (diffDays === 1) return '1 day ago';
    return `${diffDays} days ago`;
}

// Online/Offline Management
function setupOnlineStatusMonitoring() {
    window.addEventListener('online', function() {
        isOnline = true;
        hideOfflineMessage();
        updateUndoButtonState();
        updateSaveStatusDisplay();

        // Try to auto-save if we have pending changes
        if (saveStatus === 'error' || saveStatus === 'pending') {
            scheduleAutoSave();
        }
    });

    window.addEventListener('offline', function() {
        isOnline = false;
        showOfflineMessage();
        updateUndoButtonState();

        // Cancel pending save
        if (pendingSaveTimeout) {
            clearTimeout(pendingSaveTimeout);
            pendingSaveTimeout = null;
        }

        saveStatus = 'error';
        updateSaveStatusDisplay();
    });
}

function showOfflineMessage() {
    let offlineMessage = document.getElementById('offline-message');
    if (!offlineMessage) {
        offlineMessage = document.createElement('div');
        offlineMessage.id = 'offline-message';
        offlineMessage.innerHTML = `
            <div style="background: #fed7d7; border: 1px solid #feb2b2; color: #9b2c2c; padding: 12px; border-radius: 6px; margin-bottom: 15px; text-align: center;">
                <strong>No internet connection</strong> - Editing is disabled until connection is restored
            </div>
        `;
        document.body.insertBefore(offlineMessage, document.body.firstChild);
    }

    // Disable all interactive elements
    document.querySelectorAll('.song-item, .set-songs, #num_sets, #song-filter').forEach(el => {
        el.style.pointerEvents = 'none';
        el.style.opacity = '0.6';
    });
}

function hideOfflineMessage() {
    const offlineMessage = document.getElementById('offline-message');
    if (offlineMessage) {
        offlineMessage.remove();
    }

    // Re-enable interactive elements
    document.querySelectorAll('.song-item, .set-songs, #num_sets, #song-filter').forEach(el => {
        el.style.pointerEvents = 'auto';
        el.style.opacity = '1';
    });
}

function showErrorMessage(message) {
    // Simple error display - could be enhanced with better UI
    const existingError = document.getElementById('error-message');
    if (existingError) {
        existingError.remove();
    }

    const errorDiv = document.createElement('div');
    errorDiv.id = 'error-message';
    errorDiv.innerHTML = `
        <div style="background: #fed7d7; border: 1px solid #feb2b2; color: #9b2c2c; padding: 12px; border-radius: 6px; margin-bottom: 15px; text-align: center;">
            ${message}
            <button onclick="document.getElementById('error-message').remove()" style="margin-left: 10px; background: none; border: none; color: #9b2c2c; font-weight: bold; cursor: pointer;">Ã—</button>
        </div>
    `;
    document.body.insertBefore(errorDiv, document.body.firstChild);

    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (document.getElementById('error-message')) {
            document.getElementById('error-message').remove();
        }
    }, 5000);
}

// Handle Done button - save before navigating
function handleDoneButton() {
    if (!isOnline) {
        // If offline, warn user but allow navigation
        if (confirm('You are offline. Unsaved changes will be lost. Continue?')) {
            window.location.href = '/gigs/<%= @gig.id %>';
        }
        return;
    }

    // Check if there are pending changes that need saving
    if (saveStatus === 'pending' || pendingSaveTimeout) {
        // Clear any pending auto-save
        if (pendingSaveTimeout) {
            clearTimeout(pendingSaveTimeout);
            pendingSaveTimeout = null;
        }

        // Immediately save and then navigate
        performImmediateSaveAndNavigate();
    } else {
        // No pending changes, navigate immediately
        window.location.href = '/gigs/<%= @gig.id %>';
    }
}

// Immediate save function for when user wants to leave
function performImmediateSaveAndNavigate() {
    if (!isOnline) {
        window.location.href = '/gigs/<%= @gig.id %>';
        return;
    }

    saveStatus = 'saving';
    updateSaveStatusDisplay();

    const formData = new FormData();

    // Add sets data with transition information (same as auto-save)
    Object.keys(setsSongs).forEach(setNumber => {
        setsSongs[setNumber].forEach((song, index) => {
            formData.append(`sets[${setNumber}][]`, song.id);

            // Include transition data for this song
            if (song.transition_data) {
                formData.append(`transitions[${setNumber}][${song.id}][has_transition]`, song.transition_data.has_transition || false);
                formData.append(`transitions[${setNumber}][${song.id}][transition_type]`, song.transition_data.transition_type || '');
                formData.append(`transitions[${setNumber}][${song.id}][transition_notes]`, song.transition_data.transition_notes || '');
                formData.append(`transitions[${setNumber}][${song.id}][transition_timing]`, song.transition_data.transition_timing || '');
            }
        });
    });

    fetch('/gigs/<%= @gig.id %>/update_songs', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            saveStatus = 'saved';
            lastSaveTime = new Date();
            // Navigate after successful save
            window.location.href = '/gigs/<%= @gig.id %>';
        } else {
            saveStatus = 'error';
            updateSaveStatusDisplay();
            console.error('Save failed:', data.error);
            // Still allow navigation on error with confirmation
            if (confirm('Failed to save changes. Continue without saving?')) {
                window.location.href = '/gigs/<%= @gig.id %>';
            }
        }
    })
    .catch(error => {
        saveStatus = 'error';
        updateSaveStatusDisplay();
        console.error('Save error:', error);
        // Still allow navigation on error with confirmation
        if (confirm('Failed to save changes. Continue without saving?')) {
            window.location.href = '/gigs/<%= @gig.id %>';
        }
    });
}

// Keyboard Shortcuts Setup
function setupUndoKeyboardShortcuts() {
    document.addEventListener('keydown', function(e) {
        // Handle Ctrl+Z (or Cmd+Z on Mac) for undo
        if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
            e.preventDefault();
            if (hasUndoHistory() && isOnline) {
                undoLastCommand();
            }
            return;
        }

        // Prevent other keyboard shortcuts when offline
        if (!isOnline) {
            return;
        }
    });
}

// Initialize the page
document.addEventListener('DOMContentLoaded', function() {
    // Initialize all band songs data
    allBandSongs = <%= @all_band_songs_json.to_s %>;

    // Initialize existing songs in sets
    setsSongs = <%= @sets_songs_json.to_s %>;

    // Set the number of sets based on existing data
    const setNumbers = Object.keys(setsSongs).map(k => parseInt(k));
    const maxSetNumber = setNumbers.length > 0 ? Math.max(...setNumbers) : 1;
    currentSets = Math.max(Math.min(maxSetNumber, 3), 2); // Default to 2 sets minimum
    document.getElementById('num_sets').value = currentSets;

    // Initialize auto-save and undo system
    setupOnlineStatusMonitoring();
    setupUndoKeyboardShortcuts();

    generateSets();
    setupEventListeners();
    updateAvailableSongs();
    updateAllSetTimes();
    updateTotalTime();

    // Initialize UI state
    updateUndoButtonState();
    // Don't show save status initially - it will show only when saving
    saveStatus = 'saved'; // Initialize as saved to avoid showing any status
    
    // Fallback check - if sets aren't generated after 1 second, show error
    setTimeout(function() {
        const container = document.getElementById('sets-container');
        if (container && container.children.length === 0) {
            container.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #e53e3e;">Error loading sets. Please refresh the page.</div>';
        }
    }, 1000);
});

// Generate set columns
function generateSets() {
    const container = document.getElementById('sets-container');
    if (!container) {
        console.error('Sets container not found!');
        return;
    }
    
    // Clear loading message and any existing content
    container.innerHTML = '';
    
    // Update grid columns based on number of sets
    container.style.gridTemplateColumns = `repeat(${currentSets}, 1fr)`;
    
    for (let i = 1; i <= currentSets; i++) {
        const setDiv = document.createElement('div');
        setDiv.className = 'card set-column';
        setDiv.dataset.setNumber = i;
        
        setDiv.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
                <div class="set-header" data-set-number="${i}" style="cursor: pointer; padding: 8px 12px; border-radius: 6px; transition: background-color 0.2s ease;" onclick="selectSet(${i})">
                    <h3 style="margin: 0;">Set ${i} (<span class="set-count">0</span>)</h3>
                </div>
                <div style="padding: 4px 10px; background: #f7fafc; border-radius: 4px; border: 1px solid #e2e8f0; font-size: 0.85rem;">
                    <span style="font-weight: bold; color: #4a5568;">Time:</span>
                    <span class="set-time" style="color: #2d3748; margin-left: 6px;">0:00</span>
                </div>
            </div>
            <div class="set-songs" data-set="${i}" style="overflow-y: scroll; border: 1px solid #e2e8f0; border-radius: 6px; padding: 10px;">
                <div class="drop-zone-text" style="text-align: center; color: #a0aec0; padding: 20px; font-style: italic;">Drop songs here</div>
            </div>
        `;
        
        container.appendChild(setDiv);
    }
    
    // Populate sets with existing songs
    Object.keys(setsSongs).forEach(setNumber => {
        const setContainer = document.querySelector(`[data-set="${setNumber}"]`);
        if (setContainer && parseInt(setNumber) <= currentSets) {
            setContainer.innerHTML = ''; // Clear drop zone text
            setsSongs[setNumber].forEach(song => {
                addSongToSet(setContainer, song, song.transition_data);
            });
            updateSetCount(setNumber);
        }
    });
    
    setupSetDropZones();
    setupSetSelectionListeners();
}

// Helper function to check if song is the last in the set
function isLastSongInSet(setContainer, songId) {
    const setNumber = setContainer.dataset.set;
    if (!setsSongs[setNumber]) return true;

    const songsInSet = setsSongs[setNumber];
    const songIndex = songsInSet.findIndex(s => s.id === songId);
    return songIndex === songsInSet.length - 1;
}

// Helper function to check if song has an incoming transition from previous song
function hasIncomingTransition(setContainer, songId) {
    const setNumber = setContainer.dataset.set;
    if (!setsSongs[setNumber]) return false;

    const songsInSet = setsSongs[setNumber];
    const songIndex = songsInSet.findIndex(s => s.id === songId);

    // If this is the first song in the set, it can't have an incoming transition
    if (songIndex <= 0) return false;

    // Check if the previous song has a transition
    const prevSong = songsInSet[songIndex - 1];
    return prevSong?.transition_data?.has_transition === true;
}

// Add song to set
function addSongToSet(setContainer, song, transitionData = null) {
    const songDiv = document.createElement('div');
    songDiv.className = 'song-item set-song';
    songDiv.dataset.songId = song.id;
    songDiv.dataset.hasTransition = (transitionData?.has_transition) ? 'true' : 'false';
    songDiv.draggable = true;
    songDiv.style.cssText = 'margin-bottom: 8px; padding: 10px; background: #edf2f7; border: 1px solid #cbd5e0; border-radius: 6px; cursor: grab; transition: all 0.2s ease;';

    // Add practice state class if needed
    if (song.practice_state) {
        songDiv.classList.add('practice-song');
    }

    let keyHtml = song.key ? `<span style="background: #667eea; color: white; padding: 2px 6px; border-radius: 10px; font-size: 0.7rem; margin-left: 8px;">${song.key}</span>` : '';

    // Add practice state visuals
    const practiceState = createPracticeStateHTML(song);

    // Add incoming transition arrow if this song has a transition coming into it
    let incomingArrow = '';
    if (hasIncomingTransition(setContainer, song.id)) {
        incomingArrow = `<span class="incoming-transition-arrow active" style="font-size: 1em;" title="incoming transition" onclick="togglePreviousTransition('${song.id}', '${setContainer.dataset.set}')">âž”</span> `;
    }

    // Add outgoing transition arrow if this is not the last song in the set
    let outgoingArrow = '';
    if (!isLastSongInSet(setContainer, song.id)) {
        const arrowClass = (transitionData?.has_transition) ? 'active' : '';
        outgoingArrow = ` <span class="transition-arrow ${arrowClass}" style="font-size: 1em;" title="transition" onclick="toggleTransition('${song.id}', '${setContainer.dataset.set}')">âž”</span>`;
    }

    songDiv.innerHTML = `
        <div style="font-weight: bold; color: #2d3748; font-size: 0.9rem; display: flex; align-items: center; gap: 0.25rem;">
            ${incomingArrow}${practiceState.badge}${song.title}${keyHtml}${outgoingArrow}
        </div>
        <button type="button" onclick="removeSongFromSet(this)" style="position: absolute; top: 5px; right: 5px; background: #f56565; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; font-size: 12px; cursor: pointer;">Ã—</button>
    `;
    songDiv.style.position = 'relative';

    setContainer.appendChild(songDiv);
    setupSongDragEvents(songDiv);
}

// Remove song from set
function removeSongFromSet(button) {
    const songDiv = button.closest('.song-item');
    const setContainer = songDiv.closest('.set-songs');
    const setNumber = setContainer.dataset.set;
    const songId = songDiv.dataset.songId;

    // Use command pattern to remove the song
    const command = new RemoveSongCommand(songId, setNumber);
    executeCommand(command);
}

// Toggle transition state for the previous song (when clicking incoming arrow)
function togglePreviousTransition(songId, setNumber) {
    const songsInSet = setsSongs[setNumber];
    if (!songsInSet) return;

    const songIndex = songsInSet.findIndex(s => s.id === songId);
    if (songIndex <= 0) return; // No previous song

    const prevSong = songsInSet[songIndex - 1];
    toggleTransition(prevSong.id, setNumber);
}

// Toggle transition state for a song
function toggleTransition(songId, setNumber) {
    // Find current transition data
    const songsInSet = setsSongs[setNumber];
    if (!songsInSet) return;

    const songIndex = songsInSet.findIndex(song => song.id === songId);
    if (songIndex === -1) return;

    const currentTransitionData = songsInSet[songIndex].transition_data;

    // Use command pattern to toggle transition
    const command = new ToggleTransitionCommand(songId, setNumber, currentTransitionData);
    executeCommand(command);
}

// Update available songs (rebuild list in alphabetical order)
function updateAvailableSongs() {
    const usedSongIds = new Set();
    Object.values(setsSongs).forEach(songs => {
        songs.forEach(song => usedSongIds.add(song.id));
    });
    
    // Filter all band songs to exclude those in sets
    const availableSongsFiltered = allBandSongs.filter(song => !usedSongIds.has(song.id));
    
    // Sort alphabetically by title
    availableSongsFiltered.sort((a, b) => a.title.toLowerCase().localeCompare(b.title.toLowerCase()));
    
    // Rebuild the available songs container
    const availableContainer = document.getElementById('available-songs');
    availableContainer.innerHTML = '';
    
    availableSongsFiltered.forEach(song => {
        const songDiv = document.createElement('div');
        songDiv.className = 'song-item available-song';
        songDiv.dataset.songId = song.id;
        songDiv.draggable = true;
        songDiv.style.cssText = 'margin-bottom: 8px; padding: 10px; background: #f7fafc; border: 1px solid #e2e8f0; border-radius: 6px; cursor: grab; transition: all 0.2s ease;';

        // Add practice state class if needed
        if (song.practice_state) {
            songDiv.classList.add('practice-song');
        }

        let keyHtml = song.key ? `<span style="background: #667eea; color: white; padding: 2px 6px; border-radius: 10px; font-size: 0.7rem; margin-left: 8px;">${song.key}</span>` : '';

        // Add practice state visuals
        const practiceState = createPracticeStateHTML(song);

        songDiv.innerHTML = `
            <div style="font-weight: bold; color: #2d3748; font-size: 0.9rem; display: flex; align-items: center; gap: 0.25rem;">
                ${practiceState.badge}${song.title}${keyHtml}
            </div>
        `;

        availableContainer.appendChild(songDiv);
        setupSongDragEvents(songDiv);
    });
    
    // Update count
    document.getElementById('available-count').textContent = availableSongsFiltered.length;
    
    // Reapply current filter if any
    const currentFilter = document.getElementById('song-filter').value;
    if (currentFilter) {
        applyAvailableSongsFilter(currentFilter);
    }
}

// Apply filter to available songs
function applyAvailableSongsFilter(filter) {
    const filterLower = filter.toLowerCase();
    const songItems = document.querySelectorAll('.available-song');
    
    let visibleCount = 0;
    songItems.forEach(item => {
        const title = item.querySelector('div').textContent.toLowerCase();
        
        if (title.includes(filterLower)) {
            item.style.display = 'block';
            visibleCount++;
        } else {
            item.style.display = 'none';
        }
    });
    
    // Update count to show filtered results
    document.getElementById('available-count').textContent = visibleCount;
}

// Update set count
function updateSetCount(setNumber) {
    const setColumn = document.querySelector(`[data-set-number="${setNumber}"]`);
    if (setColumn) {
        const count = setsSongs[setNumber] ? setsSongs[setNumber].length : 0;
        const countSpan = setColumn.querySelector('.set-count');
        if (countSpan) {
            countSpan.textContent = count;
        }
    }
    
    // Also update the set time
    updateSetTime(setNumber);
}

// Helper function to format time from minutes
function formatTime(totalMinutes) {
    const hours = Math.floor(totalMinutes / 60);
    const minutes = Math.floor(totalMinutes % 60);
    const seconds = Math.round((totalMinutes % 1) * 60);
    
    if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    } else {
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
}

// Calculate time for a specific set
function calculateSetTime(setNumber) {
    let setMinutes = 0;
    
    if (setsSongs[setNumber]) {
        setsSongs[setNumber].forEach(song => {
            if (song.duration && song.duration.match(/^\d+:\d+$/)) {
                const parts = song.duration.split(':').map(part => parseInt(part));
                setMinutes += parts[0] + parts[1] / 60.0;
            }
        });
    }
    
    return setMinutes;
}

// Update individual set time display
function updateSetTime(setNumber) {
    const setMinutes = calculateSetTime(setNumber);
    const timeDisplay = formatTime(setMinutes);
    
    const setColumn = document.querySelector(`[data-set-number="${setNumber}"]`);
    if (setColumn) {
        const setTimeElement = setColumn.querySelector('.set-time');
        if (setTimeElement) {
            setTimeElement.textContent = timeDisplay;
        }
    }
}

// Calculate and update total time
function updateTotalTime() {
    let totalMinutes = 0;
    
    // Sum up all songs in all sets
    Object.values(setsSongs).forEach(songs => {
        songs.forEach(song => {
            if (song.duration && song.duration.match(/^\d+:\d+$/)) {
                const parts = song.duration.split(':').map(part => parseInt(part));
                totalMinutes += parts[0] + parts[1] / 60.0;
            }
        });
    });
    
    const timeDisplay = formatTime(totalMinutes);
    
    const totalTimeElement = document.getElementById('total-time');
    if (totalTimeElement) {
        totalTimeElement.textContent = timeDisplay;
    }
}

// Update all set times
function updateAllSetTimes() {
    for (let i = 1; i <= currentSets; i++) {
        updateSetTime(i);
    }
}

// Setup event listeners
function setupEventListeners() {
    // Number of sets change
    document.getElementById('num_sets').addEventListener('change', function() {
        const newSetCount = parseInt(this.value);
        const oldSetCount = currentSets;

        // Use command pattern to change set count
        const command = new ChangeSetCountCommand(oldSetCount, newSetCount);
        executeCommand(command);
    });
    
    // Song filter
    document.getElementById('song-filter').addEventListener('input', function() {
        applyAvailableSongsFilter(this.value);
        toggleClearButton(this.value);
    });

    // Handle Enter key in song filter input
    document.getElementById('song-filter').addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();

            if (this.value.trim() !== '') {
                // Get all visible available songs
                const visibleSongs = Array.from(document.querySelectorAll('.available-song'))
                    .filter(song => song.style.display !== 'none');

                // If exactly one song is visible, add it to the selected set
                if (visibleSongs.length === 1) {
                    addSongToSelectedSet(visibleSongs[0]);

                    // Clear the filter after adding the song
                    clearSongFilter();
                }
            }
        }
    });
    
    // Note: Drag events for available songs are set up in updateAvailableSongs() when songs are created

    // Global keyboard event handler for search functionality
    document.addEventListener('keydown', function(e) {
        const activeElement = document.activeElement;
        const isTypingInInput = activeElement.tagName === 'INPUT' ||
                                activeElement.tagName === 'TEXTAREA' ||
                                activeElement.isContentEditable;
        const hasModifier = e.altKey || e.ctrlKey || e.metaKey;
        const songFilter = document.getElementById('song-filter');

        // Handle ESC key to clear search
        if (e.key === 'Escape') {
            if (songFilter && songFilter.value.trim() !== '') {
                e.preventDefault();
                clearSongFilter();
                return;
            }
        }

        // Handle Enter key to add single filtered song to selected set
        if (e.key === 'Enter') {
            if (songFilter && songFilter.value.trim() !== '') {
                e.preventDefault();

                // Get all visible available songs
                const visibleSongs = Array.from(document.querySelectorAll('.available-song'))
                    .filter(song => song.style.display !== 'none');

                // If exactly one song is visible, add it to the selected set
                if (visibleSongs.length === 1) {
                    addSongToSelectedSet(visibleSongs[0]);

                    // Clear the filter after adding the song
                    clearSongFilter();
                }
                return;
            }
        }

        // Global text input handling - direct text to search box
        if (!isTypingInInput && !hasModifier && songFilter) {
            // Check if it's a printable character or backspace/delete
            const isPrintableChar = e.key.length === 1;
            const isBackspace = e.key === 'Backspace';
            const isDelete = e.key === 'Delete';

            if (isPrintableChar) {
                e.preventDefault();
                songFilter.focus();

                // Clear existing content and add the new character
                songFilter.value = e.key;

                // Move cursor to end
                songFilter.setSelectionRange(songFilter.value.length, songFilter.value.length);

                // Trigger input event to start search
                const inputEvent = new Event('input');
                songFilter.dispatchEvent(inputEvent);
            } else if ((isBackspace || isDelete) && songFilter.value.trim() !== '') {
                e.preventDefault();
                songFilter.focus();

                if (isBackspace) {
                    // Remove last character
                    songFilter.value = songFilter.value.slice(0, -1);
                } else if (isDelete) {
                    // Clear all content
                    songFilter.value = '';
                }

                // Move cursor to end
                songFilter.setSelectionRange(songFilter.value.length, songFilter.value.length);

                // Trigger input event
                const inputEvent = new Event('input');
                songFilter.dispatchEvent(inputEvent);
            }
        }
    });
}

// Add song to the currently selected set
function addSongToSelectedSet(songElement) {
    const songId = songElement.dataset.songId;
    const songData = allBandSongs.find(song => song.id === songId);

    if (!songData) {
        console.error('Song data not found for ID:', songId);
        return;
    }

    // Get the selected set number
    const setNumber = selectedSet;
    const setContainer = document.querySelector(`[data-set="${setNumber}"]`);

    if (!setContainer) {
        console.error('Set container not found for set:', setNumber);
        return;
    }

    // Check if song is already in this set
    if (setsSongs[setNumber] && setsSongs[setNumber].find(song => song.id === songId)) {
        // Song already exists in this set, do nothing
        return;
    }

    // Use command pattern to add the song
    const command = new AddSongCommand(songData, setNumber);
    executeCommand(command);

    // Scroll to show the newly added song
    setTimeout(() => {
        setContainer.scrollTop = setContainer.scrollHeight;
    }, 100); // Small delay to ensure DOM is updated
}

// Setup song drag events and double-click functionality
function setupSongDragEvents(songElement) {
    songElement.addEventListener('dragstart', function(e) {
        draggedElement = this;
        this.style.opacity = '0.5';
        this.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', this.outerHTML);
    });

    songElement.addEventListener('dragend', function() {
        this.style.opacity = '1';
        this.classList.remove('dragging');

        // Clean up any remaining drop indicators
        document.querySelectorAll('.drop-indicator').forEach(indicator => indicator.remove());

        // Reset all set container styles
        document.querySelectorAll('.set-songs').forEach(container => {
            container.style.borderColor = '#e2e8f0';
            container.style.backgroundColor = 'transparent';
        });

        draggedElement = null;
    });

    // Add double-click functionality for available songs (to add to sets)
    if (songElement.classList.contains('available-song')) {
        songElement.addEventListener('dblclick', function(e) {
            e.preventDefault();
            addSongToSelectedSet(this);
        });
    }

    // Add double-click functionality for set songs (to remove from sets)
    if (songElement.classList.contains('set-song')) {
        songElement.addEventListener('dblclick', function(e) {
            e.preventDefault();
            // Find the remove button and trigger its click event
            const removeButton = this.querySelector('button[onclick*="removeSongFromSet"]');
            if (removeButton) {
                removeSongFromSet(removeButton);
            }
        });
    }
}

// Setup set selection listeners
function setupSetSelectionListeners() {
    // Initialize indicator with the default selected set
    updateSelectedSetIndicator(selectedSet);
    updateSetHeaderStyles();
}

// Handle set selection when clicking on set headers
function selectSet(setNumber) {
    selectedSet = setNumber;
    updateSelectedSetIndicator(selectedSet);
    updateSetHeaderStyles();
}

// Update visual styling of set headers to show which is selected
function updateSetHeaderStyles() {
    document.querySelectorAll('.set-header').forEach(header => {
        const setNumber = parseInt(header.dataset.setNumber);
        if (setNumber === selectedSet) {
            header.style.backgroundColor = '#e3f2fd';
            header.style.border = '2px solid #1976d2';
        } else {
            header.style.backgroundColor = 'transparent';
            header.style.border = '2px solid transparent';
        }
    });
}

// Update the selected set indicator text
function updateSelectedSetIndicator(setNumber) {
    const indicator = document.getElementById('selected-set-name');
    if (indicator) {
        indicator.textContent = `Set ${setNumber}`;
    }
}

// Setup set drop zones with precise positioning
function setupSetDropZones() {
    document.querySelectorAll('.set-songs').forEach(setContainer => {
        setContainer.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            // Remove any existing drop indicators
            this.querySelectorAll('.drop-indicator').forEach(indicator => indicator.remove());
            
            const afterElement = getDragAfterElement(this, e.clientY);
            const dropIndicator = createDropIndicator();
            
            if (afterElement == null) {
                this.appendChild(dropIndicator);
            } else {
                this.insertBefore(dropIndicator, afterElement);
            }
            
            this.style.borderColor = '#667eea';
            this.style.backgroundColor = '#f7fafc';
        });
        
        setContainer.addEventListener('dragleave', function() {
            // Only remove indicators if we're leaving the container entirely
            if (!this.contains(event.relatedTarget)) {
                this.querySelectorAll('.drop-indicator').forEach(indicator => indicator.remove());
                this.style.borderColor = '#e2e8f0';
                this.style.backgroundColor = 'transparent';
            }
        });
        
        setContainer.addEventListener('drop', function(e) {
            e.preventDefault();
            this.style.borderColor = '#e2e8f0';
            this.style.backgroundColor = 'transparent';

            // Remove drop indicators
            this.querySelectorAll('.drop-indicator').forEach(indicator => indicator.remove());

            if (draggedElement) {
                const songId = draggedElement.dataset.songId;
                const setNumber = this.dataset.set;

                // Find song data
                const songData = allBandSongs.find(song => song.id === songId);

                if (songData) {
                    // Calculate insertion position
                    const afterElement = getDragAfterElement(this, e.clientY);
                    let insertPosition = 0;

                    if (afterElement) {
                        const songs = Array.from(this.querySelectorAll('.set-song'));
                        insertPosition = songs.indexOf(afterElement);
                    } else {
                        insertPosition = this.querySelectorAll('.set-song').length;
                    }

                    if (draggedElement.classList.contains('available-song')) {
                        // Adding from available songs - use AddSongCommand
                        const command = new AddSongCommand(songData, setNumber, insertPosition);
                        executeCommand(command);
                    } else {
                        // Moving from another set - use ReorderSongCommand
                        const fromSet = draggedElement.closest('.set-songs').dataset.set;
                        const fromPosition = Array.from(draggedElement.closest('.set-songs').querySelectorAll('.set-song')).indexOf(draggedElement);

                        // Adjust insertion position if moving within same set
                        if (fromSet === setNumber && fromPosition < insertPosition) {
                            insertPosition--;
                        }

                        const command = new ReorderSongCommand(songId, fromSet, fromPosition, setNumber, insertPosition);
                        executeCommand(command);
                    }
                }
            }
        });
    });
}

// Helper function to determine where to insert based on mouse position
function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.set-song:not(.dragging)')];
    
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

// Create a visual drop indicator
function createDropIndicator() {
    const indicator = document.createElement('div');
    indicator.className = 'drop-indicator';
    indicator.style.cssText = 'height: 3px; background: #667eea; margin: 4px 0; border-radius: 2px; opacity: 0.8;';
    return indicator;
}

// Rebuild entire set to reflect new order
function rebuildSet(setNumber) {
    const setContainer = document.querySelector(`[data-set="${setNumber}"]`);
    if (!setContainer) return;

    // Clear existing songs
    setContainer.querySelectorAll('.set-song').forEach(song => song.remove());

    // Add songs in correct order
    if (setsSongs[setNumber]) {
        setsSongs[setNumber].forEach(song => {
            addSongToSet(setContainer, song, song.transition_data);
        });
    }

    updateSetCount(setNumber); // This now also updates set time
    updateTotalTime();
}

// Legacy save function - replaced by auto-save functionality

// Toggle Available Songs column collapse
function toggleAvailableSongs() {
    const column = document.getElementById('available-songs-column');
    const mainContainer = document.getElementById('main-container');
    const burgerMenu = document.getElementById('burger-menu');
    
    availableSongsCollapsed = !availableSongsCollapsed;
    
    if (availableSongsCollapsed) {
        // Hide - slide left
        column.classList.add('sliding-out');
        burgerMenu.classList.add('active');
        
        setTimeout(() => {
            mainContainer.style.gridTemplateColumns = '1fr';
            column.style.display = 'none';
        }, 300); // Wait for slide animation to complete
        
    } else {
        // Show - slide right
        column.style.display = 'block';
        mainContainer.style.gridTemplateColumns = '300px 1fr';
        burgerMenu.classList.remove('active');
        
        // Trigger reflow to ensure display change takes effect
        column.offsetHeight;
        
        setTimeout(() => {
            column.classList.remove('sliding-out');
        }, 10); // Small delay to ensure the display change has taken effect
    }
}

// Clear song filter
function clearSongFilter() {
    const filterInput = document.getElementById('song-filter');
    filterInput.value = '';
    applyAvailableSongsFilter('');
    toggleClearButton('');
    filterInput.focus();
}

// Toggle clear button visibility
function toggleClearButton(filterValue) {
    const clearButton = document.getElementById('clear-filter');
    if (filterValue.trim() !== '') {
        clearButton.style.display = 'flex';
    } else {
        clearButton.style.display = 'none';
    }
}
</script>

<style>
.song-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.song-item:active {
    cursor: grabbing;
}

.song-item.dragging {
    opacity: 0.5;
    transform: rotate(2deg);
    z-index: 1000;
}

.set-songs {
    transition: all 0.2s ease;
}

.set-songs.drag-over {
    border-color: #667eea !important;
    background-color: #f7fafc !important;
}

.drop-indicator {
    height: 3px;
    background: #667eea;
    margin: 4px 0;
    border-radius: 2px;
    opacity: 0.8;
    transition: all 0.2s ease;
}

/* Burger Menu Styling */
.burger-icon {
    width: 20px;
    height: 15px;
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

.burger-icon span {
    display: block;
    height: 2px;
    width: 100%;
    background-color: white;
    border-radius: 1px;
    transition: all 0.3s ease;
}

#burger-menu:hover {
    background: #5a67d8;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

/* Animated burger to X transformation */
#burger-menu.active .burger-icon span:nth-child(1) {
    transform: rotate(45deg) translate(5px, 5px);
}

#burger-menu.active .burger-icon span:nth-child(2) {
    opacity: 0;
}

#burger-menu.active .burger-icon span:nth-child(3) {
    transform: rotate(-45deg) translate(7px, -6px);
}

/* Clear filter button styling */
#clear-filter {
    transition: all 0.2s ease;
    border-radius: 50%;
}

#clear-filter:hover {
    background-color: #f3f4f6;
    color: #374151;
    transform: translateY(-50%) scale(1.1);
}

/* Set header styling for clickable selection */
.set-header:hover {
    background-color: #f0f9ff !important;
}

/* Transition arrow styling */
.transition-arrow {
    color: #a0aec0; /* Soft grey */
    font-size: 0.9em;
    margin-left: 8px;
    cursor: pointer;
    opacity: 0.7;
    transition: all 0.2s ease;
    display: inline-block;
}

.transition-arrow.active {
    color: #2d3748; /* Dark/black when active */
    opacity: 1;
    font-weight: bold;
}

.transition-arrow:hover {
    opacity: 1;
    transform: scale(1.1);
}

/* Incoming transition arrow styling */
.incoming-transition-arrow {
    color: #a0aec0; /* Soft grey */
    font-size: 0.9em;
    margin-right: 8px;
    cursor: pointer;
    opacity: 0.7;
    transition: all 0.2s ease;
    display: inline-block;
}

.incoming-transition-arrow.active {
    color: #2d3748; /* Dark/black when active */
    opacity: 1;
    font-weight: bold;
}

.incoming-transition-arrow:hover {
    opacity: 1;
    transform: scale(1.1);
}

/* Contain animations within the white border */
.main-content {
    overflow: hidden !important;
}

/* Available Songs Column Animations */
#available-songs-column {
    transition: transform 0.3s ease, opacity 0.3s ease;
    overflow: hidden;
    transform: translateX(0);
}

#available-songs-column.sliding-out {
    transform: translateX(-100%);
    opacity: 0;
}

/* Responsive height adjustments */
#main-container {
    display: flex;
    flex-direction: column;
}

#main-container.grid-layout {
    display: grid;
    height: calc(100vh - 120px);
    min-height: 500px; /* Prevent layout from becoming unusable */
}

.card {
    display: flex;
    flex-direction: column;
    height: 100%;
}

#available-songs-column {
    height: 100%;
}

#available-songs-content {
    flex: 1;
    display: flex;
    flex-direction: column;
}

#available-songs {
    flex: 1;
    min-height: 300px; /* Ensure minimum usable height for scrolling */
    max-height: calc(100vh - 320px); /* Dynamic max height */
}

.set-column {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.set-songs {
    flex: 1;
    min-height: 300px; /* Ensure minimum usable height for scrolling */
    max-height: calc(100vh - 250px); /* Dynamic max height */
}

@media (max-width: 768px) {
    #main-container {
        grid-template-columns: 1fr;
        height: calc(100vh - 140px); /* Adjust for mobile */
    }

    #sets-container {
        grid-template-columns: 1fr !important;
    }

    /* On mobile, the available songs column takes full width when shown */
    #available-songs-column {
        width: 100%;
        position: relative;
    }

    /* Ensure animations still work on mobile */
    #available-songs-column.sliding-out {
        transform: translateX(-100%);
        opacity: 0;
    }

    /* Mobile scrolling adjustments */
    #available-songs {
        min-height: 250px; /* Smaller minimum for mobile */
        max-height: calc(100vh - 360px);
    }

    .set-songs {
        min-height: 250px; /* Smaller minimum for mobile */
        max-height: calc(100vh - 290px);
    }
}

/* Force scroll bars to always be visible and ensure proper overflow */
#available-songs,
.set-songs {
    overflow-y: auto !important; /* Ensure scrolling is always enabled */
    scrollbar-width: thin; /* Firefox */
    -ms-overflow-style: scrollbar; /* IE/Edge */
}

/* Ensure containers remain scrollable even at minimum heights */
@media (max-height: 600px) {
    #main-container.grid-layout {
        min-height: 400px; /* Smaller minimum for very short screens */
    }

    #available-songs {
        min-height: 200px; /* Even smaller minimum for very short screens */
    }

    .set-songs {
        min-height: 200px; /* Even smaller minimum for very short screens */
    }
}

/* Webkit browsers (Chrome, Safari) */
#available-songs::-webkit-scrollbar,
.set-songs::-webkit-scrollbar {
    width: 12px;
    appearance: auto;
}

#available-songs::-webkit-scrollbar-track,
.set-songs::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 6px;
}

#available-songs::-webkit-scrollbar-thumb,
.set-songs::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 6px;
}

#available-songs::-webkit-scrollbar-thumb:hover,
.set-songs::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}

/* Auto-save and Undo UI Styles */
.save-status {
    padding: 6px 12px;
    border-radius: 4px;
    font-weight: 500;
    transition: opacity 0.3s ease, transform 0.3s ease;
    border: 1px solid transparent;
    opacity: 0;
    transform: translateY(-10px);
}

.save-status.saving {
    background: #fff3cd;
    color: #22c55e;
    border-color: #ffeaa7;
    opacity: 1;
    transform: translateY(0);
}

.save-status.error {
    background: #f8d7da;
    color: #721c24;
    border-color: #f1c0c7;
    cursor: pointer;
    opacity: 1;
    transform: translateY(0);
}

.save-status.error:hover {
    background: #f1c0c7;
    transform: translateY(-1px);
}

#undo-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

#undo-button:not(:disabled):hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

/* Undo button animation */
#undo-button:not(:disabled):active {
    transform: translateY(0);
}

/* Practice Song Styling */
.practice-song {
    background: #fef3c7 !important;
    border: 2px solid #f59e0b !important;
    box-shadow: 0 0 8px rgba(245, 158, 11, 0.3) !important;
    transition: all 0.2s ease !important;
}

.practice-badge {
    background: #28a745;
    color: white;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: bold;
}
</style>