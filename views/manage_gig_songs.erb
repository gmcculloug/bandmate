<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 20px;">
    <!-- Burger Menu Button -->
    <button type="button" id="burger-menu" onclick="toggleAvailableSongs()" style="background: #667eea; color: white; border: none; border-radius: 6px; padding: 8px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
        <div class="burger-icon">
            <span></span>
            <span></span>
            <span></span>
        </div>
    </button>
    <h2 style="margin: 0;">Manage Songs: <%= @gig.name %></h2>
</div>

<div class="card" style="margin-bottom: 20px;">
    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">
        <div style="display: flex; align-items: center; gap: 20px; flex-wrap: wrap;">
            <div>
                <label for="num_sets" style="font-weight: bold; margin-right: 10px;">Number of Sets:</label>
                <select id="num_sets" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px;">
                    <option value="1">1</option>
                    <option value="2" selected>2</option>
                    <option value="3">3</option>
                </select>
            </div>
            
            <div style="padding: 8px 15px; background: #f7fafc; border-radius: 6px; border: 1px solid #e2e8f0;">
                <span style="font-weight: bold; color: #4a5568;">Total Time:</span>
                <span id="total-time" style="color: #2d3748; margin-left: 8px;">0:00</span>
            </div>
        </div>
        
        <div class="actions">
            <button type="button" class="btn btn-success" onclick="saveSongChanges()">Save Changes</button>
            <a href="/gigs/<%= @gig.id %>" class="btn">Cancel</a>
        </div>
    </div>
</div>


<div id="main-container" style="display: grid; grid-template-columns: 300px 1fr; gap: 20px; min-height: 600px;">
    <!-- Available Songs Column -->
    <div class="card" id="available-songs-column">
        <div style="margin-bottom: 15px;">
            <h3 style="margin: 0;">Available Songs (<span id="available-count"><%= @available_songs.count %></span>)</h3>
        </div>
        
        <div id="available-songs-content">
            <div style="margin-bottom: 15px; position: relative;">
                <input type="text" id="song-filter" placeholder="Search songs..." style="width: 100%; padding: 8px 30px 8px 8px; border: 1px solid #d1d5db; border-radius: 4px;">
                <button type="button" id="clear-filter" onclick="clearSongFilter()" style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; color: #9ca3af; cursor: pointer; font-size: 16px; padding: 0; width: 20px; height: 20px; display: none; align-items: center; justify-content: center;">×</button>
            </div>
            
            <div id="available-songs" style="max-height: 500px; overflow-y: scroll; border: 1px solid #e2e8f0; border-radius: 6px; padding: 10px;">
            <% @available_songs.each do |song| %>
                <div class="song-item available-song" data-song-id="<%= song.id %>" draggable="true" style="margin-bottom: 8px; padding: 10px; background: #f7fafc; border: 1px solid #e2e8f0; border-radius: 6px; cursor: grab; transition: all 0.2s ease;">
                    <div style="font-weight: bold; color: #2d3748; font-size: 0.9rem;">
                        <%= song.title %>
                        <% if song.key.present? %>
                            <span style="background: #667eea; color: white; padding: 2px 6px; border-radius: 10px; font-size: 0.7rem; margin-left: 8px;"><%= song.key %></span>
                        <% end %>
                    </div>
                </div>
            <% end %>
            </div>
        </div>
    </div>
    
    <!-- Sets Columns -->
    <div id="sets-container" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px;">
        <!-- Sets will be dynamically generated here -->
        <div class="loading-message" style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #718096;">
            Loading sets...
        </div>
    </div>
</div>

<script>
// Global variables
let draggedElement = null;
let currentSets = 2;
let allBandSongs = [];
let setsSongs = {};
let availableSongsCollapsed = false;

// Initialize the page
document.addEventListener('DOMContentLoaded', function() {
    // Initialize all band songs data
    allBandSongs = <%= @all_band_songs_json.to_s %>;
    
    // Initialize existing songs in sets
    setsSongs = <%= @sets_songs_json.to_s %>;
    
    // Set the number of sets based on existing data
    const setNumbers = Object.keys(setsSongs).map(k => parseInt(k));
    const maxSetNumber = setNumbers.length > 0 ? Math.max(...setNumbers) : 1;
    currentSets = Math.max(Math.min(maxSetNumber, 3), 2); // Default to 2 sets minimum
    document.getElementById('num_sets').value = currentSets;
    
    generateSets();
    setupEventListeners();
    updateAvailableSongs();
    updateAllSetTimes();
    updateTotalTime();
    
    // Fallback check - if sets aren't generated after 1 second, show error
    setTimeout(function() {
        const container = document.getElementById('sets-container');
        if (container && container.children.length === 0) {
            container.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #e53e3e;">Error loading sets. Please refresh the page.</div>';
        }
    }, 1000);
});

// Generate set columns
function generateSets() {
    const container = document.getElementById('sets-container');
    if (!container) {
        console.error('Sets container not found!');
        return;
    }
    
    // Clear loading message and any existing content
    container.innerHTML = '';
    
    // Update grid columns based on number of sets
    container.style.gridTemplateColumns = `repeat(${currentSets}, 1fr)`;
    
    for (let i = 1; i <= currentSets; i++) {
        const setDiv = document.createElement('div');
        setDiv.className = 'card set-column';
        setDiv.dataset.setNumber = i;
        
        setDiv.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <input type="radio" name="selected-set" value="${i}" id="set-radio-${i}" ${i === 1 ? 'checked' : ''} style="margin: 0;">
                    <label for="set-radio-${i}" style="margin: 0; cursor: pointer;">
                        <h3 style="margin: 0; display: inline;">Set ${i} (<span class="set-count">0</span>)</h3>
                    </label>
                </div>
                <div style="padding: 4px 10px; background: #f7fafc; border-radius: 4px; border: 1px solid #e2e8f0; font-size: 0.85rem;">
                    <span style="font-weight: bold; color: #4a5568;">Time:</span>
                    <span class="set-time" style="color: #2d3748; margin-left: 6px;">0:00</span>
                </div>
            </div>
            <div class="set-songs" data-set="${i}" style="min-height: 400px; max-height: 500px; overflow-y: scroll; border: 1px solid #e2e8f0; border-radius: 6px; padding: 10px;">
                <div class="drop-zone-text" style="text-align: center; color: #a0aec0; padding: 20px; font-style: italic;">Drop songs here</div>
            </div>
        `;
        
        container.appendChild(setDiv);
    }
    
    // Populate sets with existing songs
    Object.keys(setsSongs).forEach(setNumber => {
        const setContainer = document.querySelector(`[data-set="${setNumber}"]`);
        if (setContainer && parseInt(setNumber) <= currentSets) {
            setContainer.innerHTML = ''; // Clear drop zone text
            setsSongs[setNumber].forEach(song => {
                addSongToSet(setContainer, song);
            });
            updateSetCount(setNumber);
        }
    });
    
    setupSetDropZones();
}

// Add song to set
function addSongToSet(setContainer, song) {
    const songDiv = document.createElement('div');
    songDiv.className = 'song-item set-song';
    songDiv.dataset.songId = song.id;
    songDiv.draggable = true;
    songDiv.style.cssText = 'margin-bottom: 8px; padding: 10px; background: #edf2f7; border: 1px solid #cbd5e0; border-radius: 6px; cursor: grab; transition: all 0.2s ease;';
    
    let keyHtml = song.key ? `<span style="background: #667eea; color: white; padding: 2px 6px; border-radius: 10px; font-size: 0.7rem; margin-left: 8px;">${song.key}</span>` : '';
    
    songDiv.innerHTML = `
        <div style="font-weight: bold; color: #2d3748; font-size: 0.9rem;">${song.title}${keyHtml}</div>
        <button type="button" onclick="removeSongFromSet(this)" style="position: absolute; top: 5px; right: 5px; background: #f56565; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; font-size: 12px; cursor: pointer;">×</button>
    `;
    songDiv.style.position = 'relative';
    
    setContainer.appendChild(songDiv);
    setupSongDragEvents(songDiv);
}

// Remove song from set
function removeSongFromSet(button) {
    const songDiv = button.closest('.song-item');
    const setContainer = songDiv.closest('.set-songs');
    const setNumber = setContainer.dataset.set;
    const songId = songDiv.dataset.songId;
    
    // Remove from setsSongs data
    if (setsSongs[setNumber]) {
        setsSongs[setNumber] = setsSongs[setNumber].filter(song => song.id !== songId);
    }
    
    // Remove from DOM
    songDiv.remove();
    
    // Update count and total time
    updateSetCount(setNumber);
    updateTotalTime();
    
    // Add back to available songs
    updateAvailableSongs();
}

// Update available songs (rebuild list in alphabetical order)
function updateAvailableSongs() {
    const usedSongIds = new Set();
    Object.values(setsSongs).forEach(songs => {
        songs.forEach(song => usedSongIds.add(song.id));
    });
    
    // Filter all band songs to exclude those in sets
    const availableSongsFiltered = allBandSongs.filter(song => !usedSongIds.has(song.id));
    
    // Sort alphabetically by title
    availableSongsFiltered.sort((a, b) => a.title.toLowerCase().localeCompare(b.title.toLowerCase()));
    
    // Rebuild the available songs container
    const availableContainer = document.getElementById('available-songs');
    availableContainer.innerHTML = '';
    
    availableSongsFiltered.forEach(song => {
        const songDiv = document.createElement('div');
        songDiv.className = 'song-item available-song';
        songDiv.dataset.songId = song.id;
        songDiv.draggable = true;
        songDiv.style.cssText = 'margin-bottom: 8px; padding: 10px; background: #f7fafc; border: 1px solid #e2e8f0; border-radius: 6px; cursor: grab; transition: all 0.2s ease;';
        
        let keyHtml = song.key ? `<span style="background: #667eea; color: white; padding: 2px 6px; border-radius: 10px; font-size: 0.7rem; margin-left: 8px;">${song.key}</span>` : '';
        
        songDiv.innerHTML = `
            <div style="font-weight: bold; color: #2d3748; font-size: 0.9rem;">${song.title}${keyHtml}</div>
        `;
        
        availableContainer.appendChild(songDiv);
        setupSongDragEvents(songDiv);
    });
    
    // Update count
    document.getElementById('available-count').textContent = availableSongsFiltered.length;
    
    // Reapply current filter if any
    const currentFilter = document.getElementById('song-filter').value;
    if (currentFilter) {
        applyAvailableSongsFilter(currentFilter);
    }
}

// Apply filter to available songs
function applyAvailableSongsFilter(filter) {
    const filterLower = filter.toLowerCase();
    const songItems = document.querySelectorAll('.available-song');
    
    let visibleCount = 0;
    songItems.forEach(item => {
        const title = item.querySelector('div').textContent.toLowerCase();
        
        if (title.includes(filterLower)) {
            item.style.display = 'block';
            visibleCount++;
        } else {
            item.style.display = 'none';
        }
    });
    
    // Update count to show filtered results
    document.getElementById('available-count').textContent = visibleCount;
}

// Update set count
function updateSetCount(setNumber) {
    const setColumn = document.querySelector(`[data-set-number="${setNumber}"]`);
    if (setColumn) {
        const count = setsSongs[setNumber] ? setsSongs[setNumber].length : 0;
        const countSpan = setColumn.querySelector('.set-count');
        if (countSpan) {
            countSpan.textContent = count;
        }
    }
    
    // Also update the set time
    updateSetTime(setNumber);
}

// Helper function to format time from minutes
function formatTime(totalMinutes) {
    const hours = Math.floor(totalMinutes / 60);
    const minutes = Math.floor(totalMinutes % 60);
    const seconds = Math.round((totalMinutes % 1) * 60);
    
    if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    } else {
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
}

// Calculate time for a specific set
function calculateSetTime(setNumber) {
    let setMinutes = 0;
    
    if (setsSongs[setNumber]) {
        setsSongs[setNumber].forEach(song => {
            if (song.duration && song.duration.match(/^\d+:\d+$/)) {
                const parts = song.duration.split(':').map(part => parseInt(part));
                setMinutes += parts[0] + parts[1] / 60.0;
            }
        });
    }
    
    return setMinutes;
}

// Update individual set time display
function updateSetTime(setNumber) {
    const setMinutes = calculateSetTime(setNumber);
    const timeDisplay = formatTime(setMinutes);
    
    const setColumn = document.querySelector(`[data-set-number="${setNumber}"]`);
    if (setColumn) {
        const setTimeElement = setColumn.querySelector('.set-time');
        if (setTimeElement) {
            setTimeElement.textContent = timeDisplay;
        }
    }
}

// Calculate and update total time
function updateTotalTime() {
    let totalMinutes = 0;
    
    // Sum up all songs in all sets
    Object.values(setsSongs).forEach(songs => {
        songs.forEach(song => {
            if (song.duration && song.duration.match(/^\d+:\d+$/)) {
                const parts = song.duration.split(':').map(part => parseInt(part));
                totalMinutes += parts[0] + parts[1] / 60.0;
            }
        });
    });
    
    const timeDisplay = formatTime(totalMinutes);
    
    const totalTimeElement = document.getElementById('total-time');
    if (totalTimeElement) {
        totalTimeElement.textContent = timeDisplay;
    }
}

// Update all set times
function updateAllSetTimes() {
    for (let i = 1; i <= currentSets; i++) {
        updateSetTime(i);
    }
}

// Setup event listeners
function setupEventListeners() {
    // Number of sets change
    document.getElementById('num_sets').addEventListener('change', function() {
        const newSetCount = parseInt(this.value);
        
        // If reducing sets, move songs from removed sets back to available
        if (newSetCount < currentSets) {
            for (let i = newSetCount + 1; i <= currentSets; i++) {
                if (setsSongs[i]) {
                    delete setsSongs[i];
                }
            }
        }
        
        currentSets = newSetCount;
        generateSets();
        updateAvailableSongs();
        updateAllSetTimes();
        updateTotalTime();
    });
    
    // Song filter
    document.getElementById('song-filter').addEventListener('input', function() {
        applyAvailableSongsFilter(this.value);
        toggleClearButton(this.value);
    });
    
    // Note: Drag events for available songs are set up in updateAvailableSongs() when songs are created

    // Global keyboard event handler for search functionality
    document.addEventListener('keydown', function(e) {
        const activeElement = document.activeElement;
        const isTypingInInput = activeElement.tagName === 'INPUT' ||
                                activeElement.tagName === 'TEXTAREA' ||
                                activeElement.isContentEditable;
        const hasModifier = e.altKey || e.ctrlKey || e.metaKey;
        const songFilter = document.getElementById('song-filter');

        // Handle ESC key to clear search
        if (e.key === 'Escape') {
            if (songFilter && songFilter.value.trim() !== '') {
                e.preventDefault();
                clearSongFilter();
                return;
            }
        }

        // Global text input handling - direct text to search box
        if (!isTypingInInput && !hasModifier && songFilter) {
            // Check if it's a printable character or backspace/delete
            const isPrintableChar = e.key.length === 1;
            const isBackspace = e.key === 'Backspace';
            const isDelete = e.key === 'Delete';

            if (isPrintableChar) {
                e.preventDefault();
                songFilter.focus();

                // Clear existing content and add the new character
                songFilter.value = e.key;

                // Move cursor to end
                songFilter.setSelectionRange(songFilter.value.length, songFilter.value.length);

                // Trigger input event to start search
                const inputEvent = new Event('input');
                songFilter.dispatchEvent(inputEvent);
            } else if ((isBackspace || isDelete) && songFilter.value.trim() !== '') {
                e.preventDefault();
                songFilter.focus();

                if (isBackspace) {
                    // Remove last character
                    songFilter.value = songFilter.value.slice(0, -1);
                } else if (isDelete) {
                    // Clear all content
                    songFilter.value = '';
                }

                // Move cursor to end
                songFilter.setSelectionRange(songFilter.value.length, songFilter.value.length);

                // Trigger input event
                const inputEvent = new Event('input');
                songFilter.dispatchEvent(inputEvent);
            }
        }
    });
}

// Add song to the currently selected set
function addSongToSelectedSet(songElement) {
    const songId = songElement.dataset.songId;
    const songData = allBandSongs.find(song => song.id === songId);

    if (!songData) {
        console.error('Song data not found for ID:', songId);
        return;
    }

    // Get the selected set number
    const selectedRadio = document.querySelector('input[name="selected-set"]:checked');
    if (!selectedRadio) {
        console.error('No set selected');
        return;
    }

    const setNumber = selectedRadio.value;
    const setContainer = document.querySelector(`[data-set="${setNumber}"]`);

    if (!setContainer) {
        console.error('Set container not found for set:', setNumber);
        return;
    }

    // Check if song is already in this set
    if (setsSongs[setNumber] && setsSongs[setNumber].find(song => song.id === songId)) {
        // Song already exists in this set, do nothing
        return;
    }

    // Initialize set if it doesn't exist
    if (!setsSongs[setNumber]) {
        setsSongs[setNumber] = [];
    }

    // Add song to the end of the set
    setsSongs[setNumber].push(songData);

    // Clear drop zone text if this is the first song
    const dropZoneText = setContainer.querySelector('.drop-zone-text');
    if (dropZoneText) {
        dropZoneText.remove();
    }

    // Add the song to the DOM
    addSongToSet(setContainer, songData);

    // Scroll to show the newly added song
    setTimeout(() => {
        setContainer.scrollTop = setContainer.scrollHeight;
    }, 100); // Small delay to ensure DOM is updated

    // Update the available songs list and counts
    updateAvailableSongs();
    updateSetCount(setNumber);
    updateTotalTime();
}

// Setup song drag events and double-click functionality
function setupSongDragEvents(songElement) {
    songElement.addEventListener('dragstart', function(e) {
        draggedElement = this;
        this.style.opacity = '0.5';
        this.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', this.outerHTML);
    });

    songElement.addEventListener('dragend', function() {
        this.style.opacity = '1';
        this.classList.remove('dragging');

        // Clean up any remaining drop indicators
        document.querySelectorAll('.drop-indicator').forEach(indicator => indicator.remove());

        // Reset all set container styles
        document.querySelectorAll('.set-songs').forEach(container => {
            container.style.borderColor = '#e2e8f0';
            container.style.backgroundColor = 'transparent';
        });

        draggedElement = null;
    });

    // Add double-click functionality for available songs (to add to sets)
    if (songElement.classList.contains('available-song')) {
        songElement.addEventListener('dblclick', function(e) {
            e.preventDefault();
            addSongToSelectedSet(this);
        });
    }

    // Add double-click functionality for set songs (to remove from sets)
    if (songElement.classList.contains('set-song')) {
        songElement.addEventListener('dblclick', function(e) {
            e.preventDefault();
            // Find the remove button and trigger its click event
            const removeButton = this.querySelector('button[onclick*="removeSongFromSet"]');
            if (removeButton) {
                removeSongFromSet(removeButton);
            }
        });
    }
}

// Setup set drop zones with precise positioning
function setupSetDropZones() {
    document.querySelectorAll('.set-songs').forEach(setContainer => {
        setContainer.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            // Remove any existing drop indicators
            this.querySelectorAll('.drop-indicator').forEach(indicator => indicator.remove());
            
            const afterElement = getDragAfterElement(this, e.clientY);
            const dropIndicator = createDropIndicator();
            
            if (afterElement == null) {
                this.appendChild(dropIndicator);
            } else {
                this.insertBefore(dropIndicator, afterElement);
            }
            
            this.style.borderColor = '#667eea';
            this.style.backgroundColor = '#f7fafc';
        });
        
        setContainer.addEventListener('dragleave', function() {
            // Only remove indicators if we're leaving the container entirely
            if (!this.contains(event.relatedTarget)) {
                this.querySelectorAll('.drop-indicator').forEach(indicator => indicator.remove());
                this.style.borderColor = '#e2e8f0';
                this.style.backgroundColor = 'transparent';
            }
        });
        
        setContainer.addEventListener('drop', function(e) {
            e.preventDefault();
            this.style.borderColor = '#e2e8f0';
            this.style.backgroundColor = 'transparent';
            
            // Remove drop indicators
            this.querySelectorAll('.drop-indicator').forEach(indicator => indicator.remove());
            
            if (draggedElement) {
                const songId = draggedElement.dataset.songId;
                const setNumber = this.dataset.set;
                
                // Find song data
                const songData = allBandSongs.find(song => song.id === songId);
                
                if (songData) {
                    // Calculate insertion position
                    const afterElement = getDragAfterElement(this, e.clientY);
                    let insertPosition = 0;
                    
                    if (afterElement) {
                        const songs = Array.from(this.querySelectorAll('.set-song'));
                        insertPosition = songs.indexOf(afterElement);
                    } else {
                        insertPosition = this.querySelectorAll('.set-song').length;
                    }
                    
                    // Remove from current location
                    if (draggedElement.classList.contains('available-song')) {
                        // Moving from available songs
                    } else {
                        // Moving from another set
                        const fromSet = draggedElement.closest('.set-songs').dataset.set;
                        const fromPosition = Array.from(draggedElement.closest('.set-songs').querySelectorAll('.set-song')).indexOf(draggedElement);
                        
                        if (setsSongs[fromSet]) {
                            setsSongs[fromSet].splice(fromPosition, 1);
                            updateSetCount(fromSet);
                        }
                        
                        // Adjust insertion position if moving within same set
                        if (fromSet === setNumber && fromPosition < insertPosition) {
                            insertPosition--;
                        }
                    }
                    
                    // Add to new set at specific position
                    if (!setsSongs[setNumber]) {
                        setsSongs[setNumber] = [];
                    }
                    
                    // Check if song is already in this set at different position
                    const existingIndex = setsSongs[setNumber].findIndex(song => song.id === songId);
                    if (existingIndex !== -1) {
                        // Remove from old position
                        setsSongs[setNumber].splice(existingIndex, 1);
                        // Adjust insertion position if necessary
                        if (existingIndex < insertPosition) {
                            insertPosition--;
                        }
                    }
                    
                    // Insert at precise position
                    setsSongs[setNumber].splice(insertPosition, 0, songData);
                    
                    // Clear drop zone text if this is the first song
                    const dropZoneText = this.querySelector('.drop-zone-text');
                    if (dropZoneText) {
                        dropZoneText.remove();
                    }
                    
                    // Rebuild the entire set to reflect new order
                    rebuildSet(setNumber);
                    updateAvailableSongs();
                    
                    // Remove dragged element if it was moved from another set
                    if (!draggedElement.classList.contains('available-song')) {
                        draggedElement.remove();
                    }
                }
            }
        });
    });
}

// Helper function to determine where to insert based on mouse position
function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.set-song:not(.dragging)')];
    
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

// Create a visual drop indicator
function createDropIndicator() {
    const indicator = document.createElement('div');
    indicator.className = 'drop-indicator';
    indicator.style.cssText = 'height: 3px; background: #667eea; margin: 4px 0; border-radius: 2px; opacity: 0.8;';
    return indicator;
}

// Rebuild entire set to reflect new order
function rebuildSet(setNumber) {
    const setContainer = document.querySelector(`[data-set="${setNumber}"]`);
    if (!setContainer) return;
    
    // Clear existing songs
    setContainer.querySelectorAll('.set-song').forEach(song => song.remove());
    
    // Add songs in correct order
    if (setsSongs[setNumber]) {
        setsSongs[setNumber].forEach(song => {
            addSongToSet(setContainer, song);
        });
    }
    
    updateSetCount(setNumber); // This now also updates set time
    updateTotalTime();
}

// Save song changes
function saveSongChanges() {
    const formData = new FormData();
    
    // Add sets data
    Object.keys(setsSongs).forEach(setNumber => {
        setsSongs[setNumber].forEach((song, index) => {
            formData.append(`sets[${setNumber}][]`, song.id);
        });
    });
    
    // Show saving indicator
    const button = event.target;
    const originalText = button.textContent;
    button.textContent = 'Saving...';
    button.disabled = true;
    
    fetch('/gigs/<%= @gig.id %>/update_songs', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            window.location.href = '/gigs/<%= @gig.id %>';
        } else {
            alert('Error saving changes. Please try again.');
            button.textContent = originalText;
            button.disabled = false;
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error saving changes. Please try again.');
        button.textContent = originalText;
        button.disabled = false;
    });
}

// Toggle Available Songs column collapse
function toggleAvailableSongs() {
    const column = document.getElementById('available-songs-column');
    const mainContainer = document.getElementById('main-container');
    const burgerMenu = document.getElementById('burger-menu');
    
    availableSongsCollapsed = !availableSongsCollapsed;
    
    if (availableSongsCollapsed) {
        // Hide - slide left
        column.classList.add('sliding-out');
        burgerMenu.classList.add('active');
        
        setTimeout(() => {
            mainContainer.style.gridTemplateColumns = '1fr';
            column.style.display = 'none';
        }, 300); // Wait for slide animation to complete
        
    } else {
        // Show - slide right
        column.style.display = 'block';
        mainContainer.style.gridTemplateColumns = '300px 1fr';
        burgerMenu.classList.remove('active');
        
        // Trigger reflow to ensure display change takes effect
        column.offsetHeight;
        
        setTimeout(() => {
            column.classList.remove('sliding-out');
        }, 10); // Small delay to ensure the display change has taken effect
    }
}

// Clear song filter
function clearSongFilter() {
    const filterInput = document.getElementById('song-filter');
    filterInput.value = '';
    applyAvailableSongsFilter('');
    toggleClearButton('');
    filterInput.focus();
}

// Toggle clear button visibility
function toggleClearButton(filterValue) {
    const clearButton = document.getElementById('clear-filter');
    if (filterValue.trim() !== '') {
        clearButton.style.display = 'flex';
    } else {
        clearButton.style.display = 'none';
    }
}
</script>

<style>
.song-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.song-item:active {
    cursor: grabbing;
}

.song-item.dragging {
    opacity: 0.5;
    transform: rotate(2deg);
    z-index: 1000;
}

.set-songs {
    transition: all 0.2s ease;
}

.set-songs.drag-over {
    border-color: #667eea !important;
    background-color: #f7fafc !important;
}

.drop-indicator {
    height: 3px;
    background: #667eea;
    margin: 4px 0;
    border-radius: 2px;
    opacity: 0.8;
    transition: all 0.2s ease;
}

/* Burger Menu Styling */
.burger-icon {
    width: 20px;
    height: 15px;
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

.burger-icon span {
    display: block;
    height: 2px;
    width: 100%;
    background-color: white;
    border-radius: 1px;
    transition: all 0.3s ease;
}

#burger-menu:hover {
    background: #5a67d8;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

/* Animated burger to X transformation */
#burger-menu.active .burger-icon span:nth-child(1) {
    transform: rotate(45deg) translate(5px, 5px);
}

#burger-menu.active .burger-icon span:nth-child(2) {
    opacity: 0;
}

#burger-menu.active .burger-icon span:nth-child(3) {
    transform: rotate(-45deg) translate(7px, -6px);
}

/* Clear filter button styling */
#clear-filter {
    transition: all 0.2s ease;
    border-radius: 50%;
}

#clear-filter:hover {
    background-color: #f3f4f6;
    color: #374151;
    transform: translateY(-50%) scale(1.1);
}

/* Contain animations within the white border */
.main-content {
    overflow: hidden !important;
}

/* Available Songs Column Animations */
#available-songs-column {
    transition: transform 0.3s ease, opacity 0.3s ease;
    overflow: hidden;
    transform: translateX(0);
}

#available-songs-column.sliding-out {
    transform: translateX(-100%);
    opacity: 0;
}

@media (max-width: 768px) {
    #main-container {
        grid-template-columns: 1fr;
    }
    
    #sets-container {
        grid-template-columns: 1fr !important;
    }
    
    /* On mobile, the available songs column takes full width when shown */
    #available-songs-column {
        width: 100%;
        position: relative;
    }
    
    /* Ensure animations still work on mobile */
    #available-songs-column.sliding-out {
        transform: translateX(-100%);
        opacity: 0;
    }
}

/* Force scroll bars to always be visible */
#available-songs,
.set-songs {
    scrollbar-width: thin; /* Firefox */
    -ms-overflow-style: scrollbar; /* IE/Edge */
}

/* Webkit browsers (Chrome, Safari) */
#available-songs::-webkit-scrollbar,
.set-songs::-webkit-scrollbar {
    width: 12px;
    appearance: auto;
}

#available-songs::-webkit-scrollbar-track,
.set-songs::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 6px;
}

#available-songs::-webkit-scrollbar-thumb,
.set-songs::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 6px;
}

#available-songs::-webkit-scrollbar-thumb:hover,
.set-songs::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}
</style>